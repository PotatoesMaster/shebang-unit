#!/bin/bash

# Copyright (C) 2013, Arpinum
#
# Shebang Unit is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# Shebang Unit is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# Shebang Unit. If not, see http://www.gnu.org/licenses/lgpl.html.

# Shebang unit all in one source file

# yes/no representation used with shebang_unit parameters to activate
# stuff like colors
SBU_YES="yes"
SBU_NO="no"

# Intern to handle ok/ko exit codes
SBU_SUCCESS_STATUS_CODE=0
SBU_FAILURE_STATUS_CODE=1

# Colors for outputs
SBU_GREEN_COLOR_CODE="\\033[1;32m"
SBU_RED_COLOR_CODE="\\033[1;31m"
SBU_DEFAULT_COLOR_CODE="\\e[0m"

# Special function coding coventions
SBU_GLOBAL_SETUP_FUNCTION_NAME="global_setup"
SBU_GLOBAL_TEARDOWN_FUNCTION_NAME="global_teardown"
SBU_SETUP_FUNCTION_NAME="setup"
SBU_TEARDOWN_FUNCTION_NAME="teardown"

# Default configuration that can be modified with shebang_unit parameters
# For more information see shebang_unit usages
SBU_TEST_FILE_PATTERN=*_test.sh
SBU_USE_COLORS="${SBU_YES}"

function system::get_string_or_default() {
	local result=$1
	[[ -z "$1" ]] && result="$2"
	printf "${result}"
}

function system::get_date_in_seconds() {
	date +%s
}

function system::print_with_color() {
	if [[ "${SBU_USE_COLORS}" == "${SBU_YES}" ]]; then
		printf "$2$1$3\n"
	else
		printf "$1\n"
	fi
}

function system::array_contains() {
	local value=$1
	shift 1
	local i
	for (( i=1; i <= $#; i++ )); do
		if [[ "${!i}" == "${value}" ]]; then
			return ${SBU_SUCCESS_STATUS_CODE}
		fi
	done
	return ${SBU_FAILURE_STATUS_CODE}
}

function system::print_array() {
	local array_as_string=""
	local i
	for (( i=1; i <= $#; i++ )); do
		array_as_string+="${!i}, "
	done
	array_as_string=${array_as_string/%, /}
	printf "[%s]" "${array_as_string}"
}

function system::string_contains() {
	[[ "$1" == *"$2"* ]]
}

function assertion::equal() {
	if [[ "$1" != "$2" ]]; then
		assertion::_assertion_failed "Actual: <$2>, expected: <$1>."
	fi
}

function assertion::string_contains() {
	if ! system::string_contains "$1" "$2"; then
		assertion::_assertion_failed "String: <$1> does not contain: <$2>."
	fi
}

function assertion::string_does_not_contain() {
	if system::string_contains "$1" "$2"; then
		assertion::_assertion_failed "String: <$1> contains: <$2>."
	fi
}

function assertion::string_empty() {
	if [[ -n "$1" ]]; then
		assertion::_assertion_failed "String: <$1> is not empty."
	fi
}

function assertion::string_not_empty() {
	if [[ -z "$1" ]]; then
		assertion::_assertion_failed "The string is empty."
	fi
}

function assertion::array_contains() {
	local element=$1
	shift 1
	if ! system::array_contains "${element}" "$@"; then
		local array_as_string="$(system::print_array "$@")"
		assertion::_assertion_failed \
			"Array: <${array_as_string}> does not contain: <${element}>."
	fi
}

function assertion::array_does_not_contains() {
	local element=$1
	shift 1
	if system::array_contains "${element}" "$@"; then
		local array_as_string="$(system::print_array "$@")"
		assertion::_assertion_failed \
			"Array: <${array_as_string}> contains: <${element}>."
	fi
}

function assertion::status_code_is_success() {
	if (( $1 != ${SBU_SUCCESS_STATUS_CODE} )); then
		assertion::_assertion_failed \
			"Status code is failure instead of success." "$2"
	fi
}

function assertion::status_code_is_failure() {
	if (( $1 == ${SBU_SUCCESS_STATUS_CODE} )); then
		assertion::_assertion_failed \
			"Status code is success instead of failure." "$2"
	fi
}

function assertion::successful() {
	"$@"
	if (( $? != ${SBU_SUCCESS_STATUS_CODE} )); then
		assertion::_assertion_failed "Command is failing instead of successful."
	fi
}

function assertion::failing() {
	"$@"
	if (( $? == ${SBU_SUCCESS_STATUS_CODE} )); then
		assertion::_assertion_failed "Command is successful instead of failing."
	fi
}

function assertion::_assertion_failed() {
	local message_to_use="$(assertion::_get_assertion_message_to_use "$1" "$2")"
	printf "Assertion failed. ${message_to_use}\n"
	exit ${SBU_FAILURE_STATUS_CODE}
}

function assertion::_get_assertion_message_to_use() {
	local message=$1
	local custom_messsage=$2
	if [[ -n "${custom_messsage}" ]]; then
		printf "%s %s\n" "${message}" "${custom_messsage}"
	else
		printf "${message}\n"
	fi
}

function parser::get_public_functions_in_file() {
	local functions=()
	parser::_find_functions_in_file "$1" | parser::_filter_private_functions | {
		local name; while read name; do
			printf "${name} "
		done
	}
}

function parser::_find_functions_in_file() {
	grep -o "^function.*()" "$1" \
		| parser::_get_function_name_from_declaration \
		| tr -d " "
}

function parser::_filter_private_functions() {
	grep -v "^_.*"
}

function parser::_get_function_name_from_declaration() {
	sed "s/function\(.*\)()/\1/"
}

function runner::run_all_test_files() {
	runner::_initialise_tests_execution
	runner::_run_all_test_files_with_pattern_in_directory "$1"
	runner::_print_tests_results
	runner::_tests_are_successful
}

function runner::_initialise_tests_execution() {
	_GREEN_TESTS_COUNT=0
	_RED_TESTS_COUNT=0
	_EXECUTION_BEGINING_DATE="$(system::get_date_in_seconds)"
}

function runner::_run_all_test_files_with_pattern_in_directory() {
	local file
	for file in $(find "$1" -name "${SBU_TEST_FILE_PATTERN}"); do
		runner::_run_test_file "${file}"
	done
}

function runner::_run_test_file() {
	local file=$1
	printf "[File] ${file}\n"
	source "${file}"
	local public_functions=($(parser::get_public_functions_in_file "${file}"))
	runner::_call_function_if_in_array "${SBU_GLOBAL_SETUP_FUNCTION_NAME}" \
		"${public_functions[@]}"
	runner::_call_all_tests "${public_functions[@]}"
	runner::_call_function_if_in_array "${SBU_GLOBAL_TEARDOWN_FUNCTION_NAME}" \
		"${public_functions[@]}"
	printf "\n"
}

function runner::_call_all_tests() {
	local i
	for (( i=1; i <= $#; i++ )); do
		runner::_call_if_test_function "${!i}" "${@}"
	done
}

function runner::_call_if_test_function() {
	local function=$1
	shift 1
	if runner::_function_is_a_test "${function}"; then
		runner::_call_test_function_in_the_middle_of_setup_and_teardown \
			"${function}" "${@}"
	fi
}

function runner::_function_is_a_test() {
	local special_functions=("${SBU_GLOBAL_SETUP_FUNCTION_NAME}"
							 "${SBU_GLOBAL_TEARDOWN_FUNCTION_NAME}"
							 "${SBU_SETUP_FUNCTION_NAME}"
							 "${SBU_TEARDOWN_FUNCTION_NAME}")
	! system::array_contains "${1}" "${special_functions[@]}"
}

function runner::_call_test_function_in_the_middle_of_setup_and_teardown() {
	local test_function=$1
	shift 1

	printf "[Test] ${test_function}\n"
	( runner::_call_function_if_in_array "${SBU_SETUP_FUNCTION_NAME}" "$@" &&
	( ${test_function} ) &&
	runner::_call_function_if_in_array "${SBU_TEARDOWN_FUNCTION_NAME}" "$@" )
	runner::_parse_test_function_result $?
}

function runner::_parse_test_function_result() {
	if (( $1 == ${SBU_SUCCESS_STATUS_CODE} )); then
		(( _GREEN_TESTS_COUNT++ ))
		runner::_print_with_color "OK" ${SBU_GREEN_COLOR_CODE}
	else
		(( _RED_TESTS_COUNT++ ))
		runner::_print_with_color "KO" ${SBU_RED_COLOR_CODE}
	fi
}

function runner::_print_tests_results() {
	printf "[Results]\n"
	local color="$(runner::_getColorCodeForTestsResult)"
	local execution_time="$(runner::_get_execution_time)"
	local green_tests="Green tests: ${_GREEN_TESTS_COUNT}"
	local red_tests="red: ${_RED_TESTS_COUNT}"
	local time="in ${execution_time}s"
	runner::_print_with_color "${green_tests}, ${red_tests} ${time}" "${color}"
}

function runner::_getColorCodeForTestsResult() {
	local color_code=${SBU_GREEN_COLOR_CODE}
	if ! runner::_tests_are_successful; then
		color_code=${SBU_RED_COLOR_CODE}
	fi
	printf "${color_code}"
}

function runner::_get_execution_time() {
	local ending_date="$(system::get_date_in_seconds)"
	printf "$((${ending_date} - ${_EXECUTION_BEGINING_DATE}))"
}

function runner::_print_with_color() {
	system::print_with_color "$1" "$2" "${SBU_DEFAULT_COLOR_CODE}"
}

function runner::_tests_are_successful() {
	(( ${_RED_TESTS_COUNT} == 0 ))
}

function runner::_call_function_if_in_array() {
	local function=$1
	shift 1
	if system::array_contains "${function}" "$@"; then
		eval ${function}
	fi
}

function main::main() {
	local i
	for i in "$@"; do
		case "${i}" in
			-c=*|--colors=*)
			SBU_USE_COLORS="${i#*=}"
			shift
			;;
			-p=*|--pattern=*)
			SBU_TEST_FILE_PATTERN="${i#*=}"
			shift
			;;
		esac
	done

	runner::run_all_test_files $1
}

main::main $@