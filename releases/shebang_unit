#!/bin/bash

# Copyright (C) 2013, Arpinum
#
# Shebang Unit is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# Shebang Unit is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# Shebang Unit. If not, see http://www.gnu.org/licenses/lgpl.html.

# Shebang unit all in one source file

function configuration__load() {
  # yes/no representation used with shebang_unit parameters to activate
  # stuff like colors
  SBU_YES="yes"
  SBU_NO="no"

  # Colors for outputs
  SBU_GREEN_COLOR_CODE="\\033[1;32m"
  SBU_RED_COLOR_CODE="\\033[1;31m"
  SBU_DEFAULT_COLOR_CODE="\\e[0m"

  # Functions coding coventions
  SBU_GLOBAL_SETUP_FUNCTION_NAME="global_setup"
  SBU_GLOBAL_TEARDOWN_FUNCTION_NAME="global_teardown"
  SBU_SETUP_FUNCTION_NAME="setup"
  SBU_TEARDOWN_FUNCTION_NAME="teardown"
  SBU_FUNCTION_DECLARATION_REGEX="^[ ]*function \(.*\)()"
  SBU_PRIVATE_FUNCTION_NAME_REGEX="^_.*"

  # Default configuration that can be modified with shebang_unit parameters
  # For more information see shebang_unit usages
  SBU_TEST_FILE_PATTERN="*_test.sh"
  SBU_USE_COLORS="${SBU_YES}"
  SBU_REPORTERS="simple"

  # Internal constants
  SBU_SUCCESS_STATUS_CODE=0
  SBU_FAILURE_STATUS_CODE=1
  SBU_VALUE_SEPARATOR=","
  SBU_TEMP_DIR="/tmp/.shebang_unit"
  SBU_LAST_ASSERTION_MSG_KEY="last_assertion_message"
  SBU_REPORTERS_FD=3
}

function assertion__equal() {
	if [[ "$1" != "$2" ]]; then
		_assertion__failed "Actual: <$2>, expected: <$1>."
	fi
}

function assertion__different() {
	if [[ "$1" == "$2" ]]; then
		_assertion__failed "Both values are: <$1>."
	fi
}

function assertion__string_contains() {
	if ! system__string_contains "$1" "$2"; then
		_assertion__failed "String: <$1> does not contain: <$2>."
	fi
}

function assertion__string_does_not_contain() {
	if system__string_contains "$1" "$2"; then
		_assertion__failed "String: <$1> contains: <$2>."
	fi
}

function assertion__string_empty() {
	if [[ -n "$1" ]]; then
		_assertion__failed "String: <$1> is not empty."
	fi
}

function assertion__string_not_empty() {
	if [[ -z "$1" ]]; then
		_assertion__failed "The string is empty."
	fi
}

function assertion__array_contains() {
	local element=$1
	shift 1
	if ! system__array_contains "${element}" "$@"; then
		local array_as_string="$(system__print_array "$@")"
		_assertion__failed \
			"Array: <${array_as_string}> does not contain: <${element}>."
	fi
}

function assertion__array_does_not_contain() {
	local element=$1
	shift 1
	if system__array_contains "${element}" "$@"; then
		local array_as_string="$(system__print_array "$@")"
		_assertion__failed \
			"Array: <${array_as_string}> contains: <${element}>."
	fi
}

function assertion__status_code_is_success() {
	if (( $1 != ${SBU_SUCCESS_STATUS_CODE} )); then
		_assertion__failed \
			"Status code is failure instead of success." "$2"
	fi
}

function assertion__status_code_is_failure() {
	if (( $1 == ${SBU_SUCCESS_STATUS_CODE} )); then
		_assertion__failed \
			"Status code is success instead of failure." "$2"
	fi
}

function assertion__successful() {
	"$@"
	if (( $? != ${SBU_SUCCESS_STATUS_CODE} )); then
		_assertion__failed "Command is failing instead of successful."
	fi
}

function assertion__failing() {
	"$@"
	if (( $? == ${SBU_SUCCESS_STATUS_CODE} )); then
		_assertion__failed "Command is successful instead of failing."
	fi
}

function _assertion__failed() {
	local message_to_use="$(_assertion__get_assertion_message_to_use "$1" "$2")"
	printf "Assertion failed. ${message_to_use}\n"
	exit ${SBU_FAILURE_STATUS_CODE}
}

function _assertion__get_assertion_message_to_use() {
	local message=$1
	local custom_messsage=$2
	if [[ -n "${custom_messsage}" ]]; then
		printf "%s %s\n" "${message}" "${custom_messsage}"
	else
		printf "${message}\n"
	fi
}

function runner__run_all_test_files() {
   eval "_runner__do_run_all_test_files_and_redirect_test_outputs "$@" \
            ${SBU_REPORTERS_FD}>&1"
}

function _runner__do_run_all_test_files_and_redirect_test_outputs() {
  _runner__run_all_test_files "$@" 2>&1 | reporter__redirect_tests_outputs;
  return "${PIPESTATUS[0]}"
}

function _runner__run_all_test_files() {
	results__tests_files_start_running
	_runner__run_all_test_files_with_pattern_in_directory "$1"
	results__tests_files_end_running
	reporter__tests_files_end_running
	runner__tests_are_successful
}

function _runner__run_all_test_files_with_pattern_in_directory() {
	local file
	for file in $(find "$1" -name "${SBU_TEST_FILE_PATTERN}" | sort); do
		file_runner__run_test_file "${file}"
	done
}

function runner__tests_are_successful() {
	(( $(results__get_failing_tests_count) == 0 ))
}

function file_runner__run_test_file() {
	local file=$1
	reporter__test_file_starts_running "${file}"
	source "${file}"
	local public_functions=($(parser__get_public_functions_in_file "${file}"))
	_file_runner__call_global_setup_if_exists "${public_functions[@]}"
	_file_runner__call_all_tests "${public_functions[@]}"
	_file_runner__call_global_teardown_if_exists "${public_functions[@]}"
	reporter__test_file_ends_running
}

function _file_runner__call_global_setup_if_exists() {
  _file_runner__call_function_if_exits "${SBU_GLOBAL_SETUP_FUNCTION_NAME}" \
    "$@"
}

function _file_runner__call_global_teardown_if_exists() {
  _file_runner__call_function_if_exits "${SBU_GLOBAL_TEARDOWN_FUNCTION_NAME}" \
    "$@"
}

function _file_runner__call_all_tests() {
	local i
	for (( i=1; i <= $#; i++ )); do
		_file_runner__call_if_test_function "${!i}" "$@"
	done
}

function _file_runner__call_if_test_function() {
	local function=$1
	shift 1
	if _file_runner__function_is_a_test "${function}"; then
		test_runner__run_test "${function}" "$@"
	fi
}

function _file_runner__function_is_a_test() {
	! system__array_contains "$1" \
	                    "${SBU_GLOBAL_SETUP_FUNCTION_NAME}" \
	                    "${SBU_GLOBAL_TEARDOWN_FUNCTION_NAME}" \
	                    "${SBU_SETUP_FUNCTION_NAME}" \
	                    "${SBU_TEARDOWN_FUNCTION_NAME}"
}

function _file_runner__call_function_if_exits() {
	local function=$1
	shift 1
	if system__array_contains "${function}" "$@"; then
	  "${function}"
	fi
}

function parser__get_public_functions_in_file() {
	_parser__find_functions_in_file "$1" \
	  | _parser__filter_private_functions \
	  | awk '{ print $1 }'
}

function _parser__find_functions_in_file() {
	grep -o "${SBU_FUNCTION_DECLARATION_REGEX}" "$1" \
		| _parser__get_function_name_from_declaration
}

function _parser__filter_private_functions() {
	grep -v "${SBU_PRIVATE_FUNCTION_NAME_REGEX}"
}

function _parser__get_function_name_from_declaration() {
	sed "s/${SBU_FUNCTION_DECLARATION_REGEX}/\1/"
}

function results__tests_files_start_running() {
  database__put "sbu_successful_tests_count" "0"
  database__put "sbu_failing_tests_count" "0"
  database__put "sbu_run_beginning_date" "$(system__get_date_in_seconds)"
}

function results__tests_files_end_running() {
  database__put "sbu_run_ending_date" "$(system__get_date_in_seconds)"
}

function results__get_run_time() {
  local beginning_date="$(database__get "sbu_run_beginning_date")"
  local ending_date="$(database__get "sbu_run_ending_date")"
  printf "$(( ending_date - beginning_date ))"
}

function results__get_successful_tests_count() {
  database__get "sbu_successful_tests_count"
}

function results__increment_successful_tests() {
  local count="$(results__get_successful_tests_count)"
  database__put "sbu_successful_tests_count" "$(( count + 1 ))"
}

function results__get_failing_tests_count() {
  database__get "sbu_failing_tests_count"
}

function results__increment_failing_tests() {
  local count="$(results__get_failing_tests_count)"
  database__put "sbu_failing_tests_count" "$(( count + 1 ))"
}


function test_runner__run_test() {
	local test_function=$1
	shift 1
  reporter__test_starts_running "${test_function}"
	(
	  _test_runner__call_setup_if_exists "$@" \
	    && _test_runner__call_test_fonction "${test_function}"
	  local setup_and_test_code=$?
	  _test_runner__call_teardown_if_exists "$@"
	  (( $? == ${SBU_SUCCESS_STATUS_CODE} \
	  &&  ${setup_and_test_code} == ${SBU_SUCCESS_STATUS_CODE} ))
	)
	_test_runner__parse_test_function_result $?
}

function _test_runner__call_test_fonction() {
  ( "$1" )
}

function _test_runner__call_setup_if_exists() {
  _test_runner__call_function_if_exits "${SBU_SETUP_FUNCTION_NAME}" "$@"
}

function _test_runner__call_teardown_if_exists() {
  _test_runner__call_function_if_exits "${SBU_TEARDOWN_FUNCTION_NAME}" "$@"
}

function _test_runner__parse_test_function_result() {
	if (( $1 == ${SBU_SUCCESS_STATUS_CODE} )); then
		results__increment_successful_tests
		reporter__test_has_succeeded
	else
		results__increment_failing_tests
		reporter__test_has_failed
	fi
}

function _test_runner__call_function_if_exits() {
	local function=$1
	shift 1
	if system__array_contains "${function}" "$@"; then
	  "${function}"
	fi
}

function reporter__initialise() {
  local reporter_dir="${SBU_TEMP_DIR}/reporter"
  mkdir -p "${reporter_dir}"
  eval "exec ${SBU_REPORTERS_FD}<> ${reporter_dir}/$(system__random)"
}

function reporter__release() {
  eval "exec ${SBU_REPORTERS_FD}>&-"
}

function reporter__tests_files_end_running() {
	reporter__for_each_reporter \
	  _reporter__call_function tests_files_end_running "$@"
}

function reporter__test_starts_running() {
	reporter__for_each_reporter \
	  _reporter__call_function test_starts_running "$@"
}

function reporter__test_has_succeeded() {
	reporter__for_each_reporter \
	  _reporter__call_function test_has_succeeded "$@"
}

function reporter__test_has_failed() {
	reporter__for_each_reporter \
	  _reporter__call_function test_has_failed "$@"
}

function reporter__test_file_starts_running() {
	reporter__for_each_reporter \
	  _reporter__call_function test_file_starts_running "$@"
}

function reporter__test_file_ends_running() {
	reporter__for_each_reporter \
	  _reporter__call_function test_file_ends_running "$@"
}

function reporter__redirect_tests_outputs() {
	reporter__for_each_reporter \
	  _reporter__call_function redirect_test_output "$@"
}

function _reporter__call_function() {
  local function=$1
  shift 1
  "${reporter}_reporter__${function}" "$@" >&${SBU_REPORTERS_FD}
}

function reporter__for_each_reporter() {
  local reporter
  for reporter in ${SBU_REPORTERS//${SBU_VALUE_SEPARATOR}/ }; do
    "$@"
  done
}

function _reporter__get_color_code_for_tests_result() {
	local color_code=${SBU_GREEN_COLOR_CODE}
	if ! runner__tests_are_successful; then
		color_code=${SBU_RED_COLOR_CODE}
	fi
	printf "${color_code}"
}


function simple_reporter__tests_files_end_running() {
	printf "[Results]\n"
	local color="$(_reporter__get_color_code_for_tests_result)"
	local green_tests="Green tests: $(results__get_successful_tests_count)"
	local red_tests="red: $(results__get_failing_tests_count)"
	local time="in $(results__get_run_time)s"
	local message="${green_tests}, ${red_tests} ${time}"
	system__print_line_with_color "${message}" "${color}"
}

function simple_reporter__test_file_starts_running() {
	printf "[File] $1\n"
}

function simple_reporter__test_file_ends_running() {
	printf "\n"
}

function simple_reporter__test_starts_running() {
	printf "[Test] $1\n"
}

function simple_reporter__test_has_succeeded() {
  system__print_line_with_color "OK" ${SBU_GREEN_COLOR_CODE}
}

function simple_reporter__test_has_failed() {
  system__print_line_with_color "KO" ${SBU_RED_COLOR_CODE}
}

function simple_reporter__redirect_test_output() {
  local text
  while read text; do
    printf "${text}\n"
  done
}

function dots_reporter__tests_files_end_running() {
	local color="$(_reporter__get_color_code_for_tests_result)"
	local texte="$(runner__tests_are_successful && printf "OK" || printf "KO")"
	system__print_line_with_color "${texte}" "${color}"
}

function dots_reporter__test_file_starts_running() {
	:
}

function dots_reporter__test_file_ends_running() {
	:
}

function dots_reporter__test_starts_running() {
	:
}

function dots_reporter__test_has_succeeded() {
  system__print_with_color "." ${SBU_GREEN_COLOR_CODE}
}

function dots_reporter__test_has_failed() {
  system__print_with_color "F" ${SBU_RED_COLOR_CODE}
}

function dots_reporter__redirect_test_output() {
  local text
  while read text; do
   :
  done
}

function database__initialise() {
  _SBU_DB_TOKEN="$(system__random)"
  _database__ensure_directory_exists
}

function database__release() {
  rm -rf "$(_database__get_dir)"
}

function database__put() {
  _database__ensure_directory_exists
  printf "%s" "$2" > "$(_database__get_dir)/$1"
}

function database__post() {
  _database__ensure_directory_exists
  printf "%s" "$2" >> "$(_database__get_dir)/$1"
}

function database__put_variable() {
  _database__ensure_directory_exists
  database__put "$1" "${!1}"
}

function database__get() {
  [[ -e "$(_database__get_dir)/$1" ]] && cat "$(_database__get_dir)/$1"
}

function _database__ensure_directory_exists() {
  mkdir -p "$(_database__get_dir)"
}

function _database__get_dir() {
  printf "${SBU_TEMP_DIR}/database/${_SBU_DB_TOKEN}"
}

function system__get_string_or_default() {
	local result=$1
	[[ -z "$1" ]] && result="$2"
	printf "${result}"
}

function system__get_date_in_seconds() {
	date +%s
}

function system__print_line_with_color() {
  system__print_with_color "$@"
  printf "\n"
}

function system__print_with_color() {
	if [[ "${SBU_USE_COLORS}" == "${SBU_YES}" ]]; then
		printf "$2$1${SBU_DEFAULT_COLOR_CODE}"
	else
		printf "$1"
	fi
}

function system__array_contains() {
	local value=$1
	shift 1
	local i
	for (( i=1; i <= $#; i++ )); do
		if [[ "${!i}" == "${value}" ]]; then
			return ${SBU_SUCCESS_STATUS_CODE}
		fi
	done
	return ${SBU_FAILURE_STATUS_CODE}
}

function system__print_array() {
	local array_as_string=""
	local i
	for (( i=1; i <= $#; i++ )); do
		array_as_string+="${!i}, "
	done
	array_as_string=${array_as_string/%, /}
	printf "[%s]" "${array_as_string}"
}

function system__string_contains() {
	[[ "$1" == *"$2"* ]]
}

function system__random() {
  printf "${RANDOM}"
}

function main__main() {
	configuration__load
  local parsed_arguments=0
  _main__parse_arguments "$@"
  shift ${parsed_arguments}
  _main__assert_only_one_argument_left $#
	_main__assert_reporters_are_known

	[[ "${SBU_NO_RUN}" != "${SBU_YES}" ]] \
	  && _main__run_all_test_files $1
}

function _main__parse_arguments() {
	local argument
	for argument in "$@"; do
		case "${argument}" in
			-c=*|--colors=*)
			SBU_USE_COLORS="${argument#*=}"
			(( parsed_arguments++ ))
			;;
			-p=*|--pattern=*)
			SBU_TEST_FILE_PATTERN="${argument#*=}"
			(( parsed_arguments++ ))
			;;
			-r=*|--reporters=*)
			SBU_REPORTERS="${argument#*=}"
			(( parsed_arguments++ ))
			;;
			--no-run)
			SBU_NO_RUN="${SBU_YES}"
			(( parsed_arguments++ ))
			;;
			-h|--help)
			_main__print_full_usage
			exit ${SBU_SUCCESS_STATUS_CODE}
			;;
			-*|--*)
			_main__print_illegal_option "${argument}"
      _main__print_usage_and_exit_with_code ${SBU_FAILURE_STATUS_CODE}
			;;
		esac
	done
}

function 	_main__assert_reporters_are_known() {
  reporter__for_each_reporter _main__fail_if_reporter_unknown
}

function _main__fail_if_reporter_unknown() {
  if [[ "${reporter}" != "simple" && "${reporter}" != "dots" ]]; then
    printf "$(_main__get_script_name): unknown reporter <${reporter}>\n"
    exit ${SBU_FAILURE_STATUS_CODE}
  fi
}

function _main__print_illegal_option() {
  local option="${1%=*}"
  option="${option#-}"
  option="${option#-}"
  printf "$(_main__get_script_name): illegal option -- ${option}\n"
}

function _main__assert_only_one_argument_left() {
  if (( $1 > 1 )); then
    printf "$(_main__get_script_name): only one path is allowed\n"
    _main__print_usage_and_exit_with_code ${SBU_FAILURE_STATUS_CODE}
  fi
}

function _main__get_script_name() {
  basename "${BASH_SOURCE[0]}"
}

function _main__print_usage_and_exit_with_code() {
  _main__print_usage
	exit $1
}

function _main__print_full_usage() {
  _main__print_usage
  local script="$(_main__get_script_name)"
  printf "\n\
[options]
-c, --colors=${SBU_YES} or ${SBU_NO}
  tests output with colors or no
-h
  print usage
-p, --pattern=<pattern>
  pattern to filter test files in path
-r, --reporters=<reporter1,reporter2>
  comma-separated reporters

[examples]
${script} .
  run all tests in current directory
${script} -p=*test.sh sources/test
  run all tests files ending with test.sh in sources/test
\n"
}

function _main__print_usage() {
  printf "\
usage: $(_main__get_script_name) [options] path
       run all tests in path\n"
}

function _main__run_all_test_files() {
  _main__initialise
	runner__run_all_test_files "$1"
	local status=$?
	_main__release
	return ${status}
}

function _main__initialise() {
  database__initialise
  reporter__initialise
}

function _main__release() {
  reporter__release
  database__release
}

main__main $@